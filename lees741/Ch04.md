# Ch04. 부호화와 발전
> 애플리케이션은 시간이 지남에 따라 변한다. 대부분의 경우 애플리케이션을 변경하면 저장하는 데이터의 형태도 변경해야 한다.
* 데이터가 변경될 때 대규모 애플리케이션에서는 코드 변경이 즉시 반영되지 않을 수 있다. (Rolling Update 등의 이유)
* 예전 버전과 새로운 버전의 코드가 공존하는 시점이 생기고 시스템이 원활하게 실행되려면 양방향으로 데이터 호환성을 유지해야 한다.

#### 하위 호환성
* 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
  * 새로운 코드는 예전 코드가 기록한 데이터 형식을 알기 때문에 하위 호환성 달성은 일반적으로 어렵지 않다.

#### 상위 호환성
* 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
  * 예전 코드가 새로운 코드에 의해 추가된 데이터를 무시할 수 있어야 하기 때문에 더 어렵다.

## 데이터  부호화 형식
> 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 메모리에서 사용하는 데이터 구조와는 다른 형태인 일련의 바이트열로 데이터를 부호화해야 한다.
* 인메모리 표현에서 바이트열로의 전환을 부호화(직렬화, 마샬링)이라고 하며, 그 반대를 복호화(파싱, 역직렬화, 언마샬링)라고 한다.
  * 마샬링: 사전적 의미는 정렬시키기, 순위 결정 > 데이터를 잘 정돈된 상태로 만드는 것을 의미

### 언어별 형식
> 많은 프로그래밍 언어는 부호화 기능이 내장되어 있다.

#### 장점
* 최소한의 추가 코드로 인메모리 객체를 저장하고 복원 가능 

#### 단점
* 특정 프로그래밍 언어에 묶여 있어 다른 언어에서 데이터 읽기 어려움
* 복호화 과정이 임의의 클래스를 인스턴스화하는 것인데 이는 공격자가 임의 코드를 실행하는 것과 같은 보안 문제를 발생시킴
  * [Deserialization Vulnerabilities in Java - Baeldung](https://www.baeldung.com/java-deserialization-vulnerabilities)
* 상위, 하위 호환성 문제가 등한시
* 효율이 나쁨
  * ex. 자바 내장 직렬화는 성능이 좋지 않고 비대해지는 부호화로 유명

### JSON과 XML, 이진 변형

#### 텍스트 형식 부호화
> 어느 정도 사람이 읽을 수 있는 텍스트 형식의 부호화 방식 (JSON, XML, CSV)
> 
> 특정 데이터를 나타낼 때 모호하다는 문제, 데이터 크기가 크다는 문제 등의 결점이 있다.
* JSON: 주로 웹 브라우저에 대한 지원과 XML 대비 단순함 덕분에 인기가 높다.
* XML: 너무 장황하고 불필요하게 복잡하다고 비판 받는다.

#### 이진 형식 부호화
> 좀 더 간편하고 파싱이 빠른 형식 (BSON, 메시지팩, WBXML)
* 데이터 크기를 줄이기 위해 JSON, XML 등의 이진 부호화 변형 버전이 널리 개발되고 다양한 틈새 시장에서 채택됐지만 텍스트 버전처럼 널리 채택되진 않음
* 약간의 공간 절약이 가능하지만 가독성을 해칠 만큼 가치가 있는지 고려해야 함 (trade-off)

### 스리프트와 프로토콜 버퍼
> 아파치 스리프트와 프로토컬 버퍼는 같은 원리를 기반으로 한 이진 부호화 라이브러리

* 둘 다 부호화할 데이터를 위한 스키마가 필요
* 부호화된 데이터는 필드 이름이 없는 대신 (스키마 정의에 나타난) 숫자와 같은 필드 태그를 포함

#### 필드 태그와 스키마 발전
> 스키마는 시간이 지남에 따라 필연적으로 변한다. (스키마 발전) 이 때문에 하위 호환성과 상위 호환성을 보장해야 한다.
* 필드에 새로운 태그 번호를 부여하는 방식으로 스키마에 새로운 필드 추가 가능 (단, optional이거나 기본값을 가져야 한다.)
  * 예전 코드에서 새로운 데이터를 읽을 때 해당 필드를 간단히 무시 가능 (상위 호환성)
  * 필드 번호가 계속 같은 의미를 가지기 때문에 새로운 코드가 예전 데이터를 항상 읽을 수 있음 (하위 호환성)
* 마찬가지로 optional 필드만 삭제 가능

#### 데이터타입과 스키마 발전
* 필드 데이터타입 변경은 불가능하지는 않지만 데이터가 손실될 위험이 있다.
  * ex. 32비트 정수를 64비트 정수로 변경

### 아브로
> 💡 읽기 작업시 특정 데이터를 부호화한 스키마를 어떻게 알 수 있을까?

#### 많은 레코드가 있는 대용량 파일
- 모두 동일한 스키마로 부호화된 수백만 개 레코드를 포함한 큰 파일을 저장하는 용도가 일반적 (하둡)
- 파일의 시작 부분에 한 번만 쓰기 스키마를 포함시키면 된다. (객체 컨테이너 파일)

#### 개별적으로 기록된 레코드를 가진 데이터베이스
- 모든 부호화된 레코드의 시작 부분에 버전 번호 기록
- 데이터베이스에는 스키마 버전 목록을 유지
- 스키마 버전들이 설명서처럼 동작해 스키마 호환성 체크를 직접 할 수 있다.

#### 동적 생성 스키마
- 프로토콜 버퍼와 스리프트와 달리 아브로는 스키마에 태그 번호가 포함돼 있지 않기 때문에 동적 생성 스키마에 더 친숙하다.
- 각 데이터베이스 테이블에 맞게 레코드 스키마를 생성하고 각 칼럼은 해당 레코드의 필드가 된다.
- 스리프트나 프로토콜 버퍼에서는 필드 태그를 변경된 칼럼 이름과 수동으로 매핑해줘야 한다.

### 스키마의 장점
- 이진 부호화 형식 스키마 언어는 XML, JSON 스키마보다 훨씬 간단하며 정규표현식 등 더 자세한 유효성 검사를 지원한다.
- 많은 데이터 시스템이 이진 부호화를 독자적으로 구현
  - ex. JDBC API

## 데이터플로 모드
### 데이터베이스를 통한 데이터플로
> 데이터베이스에 저장하는 것은 미래의 자신에게 메세지를 전송하는 것과 유사하다.
- 예전 코드가 저장한 데이터를 새로운 코드에서 읽으려면 하위 호환성 반드시 필요
- 일반적으로 동시에 다양한 프로세스가 DB 접근하는 일은 흔하기 때문에 새로운 코드가 기록한 코드를 예전 코드가 읽을 수도 있음 > 상위 호환성도 필요
  - 주의하지 않으면 데이터가 유실될 수 있음 (unknown 필드를 읽고 재부호화하는 과정에서 유실 가능)

#### 다양한 시점에 기록된 다양한 값
> 데이터가 코드보다 더 오래 산다: 애플리케이션 업그레이드는 금방 이뤄지지만, 데이터는 오래된 데이터가 계속 남아 있는 경우가 많음
- 데이터를 새로운 스키마로 재작성(마이그레이션) 가능하지만 비용이 매우 클 수도 있다.
- 대신 `null`값을 기본값으로 추가하는 기능을 대부분의 데이터베이스에서 지원 (MySQL은 예외?)

### 서비스를 통한 데이터플로: REST와 RPC
- 서버에서 API를 제공(서비스)하면 클라이언트는 요청을 보냄 (HTTP, URL, TLS, HTML)
- 서버 자체가 다른 서비스의 클라이언트일 수 있음 (MSA) > 애플리케이션 변경과 유지보수를 쉽게 만들어준다.
- 서비스는 DB와 유사하지만 차이점이 존재
  - 클라이언트가 데이터를 제출하고 질의하는 것을 허용
  - 데이터베이스는 임의 질의를 허용하는 반면 서비스는 미리 정해진 입출력만 허용된 API 공개 (약간의 캡슐화)

#### 웹 서비스
> 대중적인 두 가지 방법인 REST와 SOAP이 있다.
- REST: HTTP의 원칙을 토대로 한 설계 철학. 간단한 데이터 타입을 강조하며 URL을 사용해 리소스를 식별하는 특징이 있음
  - 디버깅이 쉬움: 웹브라우저나 `curl` 명령으로 간단히 실험 가능
- SOAP: XML 기반 프로토콜. 사람이 읽기 어렵고 수동 메시지 구성이 어려워서 도구 지원, IDE 의존이 강하다.

#### 원격 프로시저 호출(RPC) 문제
> RPC: 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 추상화 한 것
> (위치 투명성)
- 그러나 애초에 둘은 근본적으로 달라서 결함이 존재한다.
  - 네트워크 요청은 여러 요인으로 실패가 가능하다. (Timeout, Retry, 지연시간이 매우 다양, 요청 크기 다양함)

### 메시지 전달 데이터 플로
> 메시지를 직접 네트워크 연결로 전송하지 않고 임시로 메시지를 저장하는 메시지 브로커(메시지 큐)를 거쳐 전송
> 
> ex. 아파치 카프카

- 수신자가 사용 불가능하거나 과부하 상태라면 브로커가 버퍼 역할을 할 수 있다.
- 죽었던 프로세스에 메시지를 다시 전달 가능하기 때문에 메시지 유실 방지할 수 있다.
- 송신자가 수신자의 IP 주소나 포트번호를 알 필욕 없다.
- 하나의 메시지를 여러 수신자에게 전송 가능하다.
- 송신자와 수신자가 논리적으로 분리된다.

#### 메시지 브로커
- 생산자(여럿 가능)가 큐나 토픽으로 메시지를 전송하면 컨슈머(여럿 가능)가 소비하는 방식
- 메시지를 받은 컨슈머는 다른 토픽으로 메시지를 게시하거나 송신자가 소비하는 토픽으로 메시지를 전송하는 등 응답도 가능